Index: build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle.kts b/build.gradle.kts
--- a/build.gradle.kts	
+++ b/build.gradle.kts	
@@ -36,6 +36,7 @@
 dependencies {
     detektPlugins("io.gitlab.arturbosch.detekt:detekt-formatting:1.19.0")
     implementation(kotlin("stdlib-jdk8"))
+    implementation("io.arrow-kt:arrow-core:1.0.1")
 }
 
 val generateGithubLexer = task<GenerateLexerTask>("generateGithubLexer") {
Index: src/main/kotlin/com/github/fantom/codeowners/grouping/changes/CodeownersChangesGroupingPolicy.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/kotlin/com/github/fantom/codeowners/grouping/changes/CodeownersChangesGroupingPolicy.kt b/src/main/kotlin/com/github/fantom/codeowners/grouping/changes/CodeownersChangesGroupingPolicy.kt
--- a/src/main/kotlin/com/github/fantom/codeowners/grouping/changes/CodeownersChangesGroupingPolicy.kt	
+++ b/src/main/kotlin/com/github/fantom/codeowners/grouping/changes/CodeownersChangesGroupingPolicy.kt	
@@ -42,24 +42,27 @@
         if (!codeownersManager.isAvailable) return nextPolicyParent
 
         val file = resolveVirtualFile(nodePath)
-        file?.let { codeownersManager.getFileOwners(it) }?.let { ownersRef ->
-            val grandParent = nextPolicyParent ?: subtreeRoot
-            val cachingRoot = getCachingRoot(grandParent, subtreeRoot)
-            val owners = if (ownersRef.isEmpty()) {
-                emptySet()
-            } else {
-                ownersRef.values.first().ref.owners.toSet()
-            }
-            CODEOWNERS_CACHE.getValue(cachingRoot).getOrPut(grandParent) { mutableMapOf() }[owners]?.let { return it }
+        file
+            // TODO handle error properly
+            ?.let { codeownersManager.getFileOwners(it).orNull() }
+            ?.let { ownersRef ->
+                val grandParent = nextPolicyParent ?: subtreeRoot
+                val cachingRoot = getCachingRoot(grandParent, subtreeRoot)
+                val owners = if (ownersRef.isEmpty()) {
+                    emptySet()
+                } else {
+                    ownersRef.values.first().ref.owners.toSet()
+                }
+                CODEOWNERS_CACHE.getValue(cachingRoot).getOrPut(grandParent) { mutableMapOf() }[owners]?.let { return it }
 
-            CodeownersChangesBrowserNode(owners).let {
-                it.markAsHelperNode()
-                model.insertNodeInto(it, grandParent, grandParent.childCount)
+                CodeownersChangesBrowserNode(owners).let {
+                    it.markAsHelperNode()
+                    model.insertNodeInto(it, grandParent, grandParent.childCount)
 
-                CODEOWNERS_CACHE.getValue(cachingRoot).getOrPut(grandParent) { mutableMapOf() }[owners] = it
-                return it
-            }
-        }
+                    CODEOWNERS_CACHE.getValue(cachingRoot).getOrPut(grandParent) { mutableMapOf() }[owners] = it
+                    return it
+                }
+            }
         return nextPolicyParent
     }
 
Index: src/main/kotlin/com/github/fantom/codeowners/grouping/usage/CodeownersGroupingRule.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/kotlin/com/github/fantom/codeowners/grouping/usage/CodeownersGroupingRule.kt b/src/main/kotlin/com/github/fantom/codeowners/grouping/usage/CodeownersGroupingRule.kt
--- a/src/main/kotlin/com/github/fantom/codeowners/grouping/usage/CodeownersGroupingRule.kt	
+++ b/src/main/kotlin/com/github/fantom/codeowners/grouping/usage/CodeownersGroupingRule.kt	
@@ -29,8 +29,14 @@
     }
 
     private fun getGroupForFile(virtualFile: VirtualFile): UsageGroup? {
-        // TODO need to return explicit error instead of null/empty map/empty owners list
-        return codeownersManager.getFileOwners(virtualFile)?.values?.firstOrNull()?.ref?.owners?.toSet()
+        return codeownersManager.getFileOwners(virtualFile)
+            // TODO handle error properly
+            .orNull()
+            ?.values
+            ?.firstOrNull()
+            ?.ref
+            ?.owners
+            ?.toSet()
             ?.let(::CodeownersGroup)
     }
 
Index: src/main/kotlin/com/github/fantom/codeowners/CodeownersManager.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/kotlin/com/github/fantom/codeowners/CodeownersManager.kt b/src/main/kotlin/com/github/fantom/codeowners/CodeownersManager.kt
--- a/src/main/kotlin/com/github/fantom/codeowners/CodeownersManager.kt	
+++ b/src/main/kotlin/com/github/fantom/codeowners/CodeownersManager.kt	
@@ -1,5 +1,8 @@
 package com.github.fantom.codeowners
 
+import arrow.core.Either
+import arrow.core.Either.Left
+import arrow.core.Either.Right
 import com.github.fantom.codeowners.file.type.CodeownersFileType
 import com.github.fantom.codeowners.indexing.CodeownersEntryOccurrence
 import com.github.fantom.codeowners.indexing.CodeownersFilesIndex
@@ -32,6 +35,8 @@
 import com.intellij.openapi.vfs.newvfs.BulkFileListener
 import com.intellij.openapi.vfs.newvfs.events.VFileEvent
 import com.intellij.psi.PsiManager
+import com.intellij.psi.search.FilenameIndex
+import com.intellij.psi.search.ProjectScope
 import com.intellij.util.Time
 import com.intellij.util.messages.MessageBusConnection
 import com.intellij.util.messages.Topic
@@ -53,6 +58,13 @@
 
 data class OwnersFileReference(val url: String?, val ref: OwnersReference)
 
+sealed class GetFileOwnersError {
+    object InDumbMode : GetFileOwnersError()
+    object NotInProject : GetFileOwnersError()
+    object Disposed : GetFileOwnersError()
+    object NoVirtualFile : GetFileOwnersError()
+}
+
 /**
  * [CodeownersManager] handles CODEOWNERS files indexing and status caching.
  */
@@ -145,29 +157,30 @@
      * Checks if file has owners.
      *
      * @param file current file
-     * @return file owners by codeowner file type or null if cannot retrieve them due to project or IDE state (dumb mode, disposed)
+     * @return file owners by codeowner file type or error. Empty if no owners defined in any of codeonwers files.
+     * Error if cannot retrieve them due to project or IDE state (dumb mode, disposed)
      */
     @Suppress("ComplexCondition", "ComplexMethod", "NestedBlockDepth", "ReturnCount")
-    fun getFileOwners(file: VirtualFile): Map<CodeownersFileType, OwnersFileReference>? {
+    fun getFileOwners(file: VirtualFile): Either<GetFileOwnersError, Map<CodeownersFileType, OwnersFileReference>> {
         LOGGER.trace(">getFileOwners ${file.name}")
         expiringStatusCache[file]?.let {
             LOGGER.trace("<getFileOwners ${file.name} cached ${it.entries.joinToString(",")}")
-            return it
+            return Right(it)
         }
         if (DumbService.isDumb(project)) {
             LOGGER.trace("<getFileOwners ${file.name} dumbMode, null")
-            return null
+            return Left(GetFileOwnersError.InDumbMode)
         }
         if (!Utils.isInProject(file, project)) {
             LOGGER.trace("<getFileOwners ${file.name} not in project, emptyList")
-            return emptyMap()
+            return Left(GetFileOwnersError.NotInProject)
         }
         if (ApplicationManager.getApplication().isDisposed || project.isDisposed ||
             /*|| !isEnabled  || */
             NoAccessDuringPsiEvents.isInsideEventProcessing()
         ) {
             LOGGER.trace("<getFileOwners ${file.name} emptyList")
-            return emptyMap()
+            return Left(GetFileOwnersError.Disposed)
         }
         val ownersMap = mutableMapOf<CodeownersFileType, OwnersFileReference>()
 //        var matched = false
@@ -176,33 +189,32 @@
 //            if (CodeownersBundle.ENABLED_LANGUAGES[fileType] != true) {
 //                continue
 //            }
-            val codeownersFiles = cachedCodeownersFilesIndex[fileType] ?: emptyList()
+            val codeownersFiles = cachedCodeownersFilesIndex[fileType] ?: continue
             val filesCount = codeownersFiles.size
             LOGGER.trace(">>getFileOwners ${file.name}, inspecting $fileType with $filesCount codeowners files")
 
             @Suppress("LoopWithTooManyJumpStatements")
             for (codeownersFile in codeownersFiles) {
                 ProgressManager.checkCanceled()
-                getFileOwners(file, codeownersFile)?.also {
-                    ownersMap[fileType] = it
+                getFileOwners(file, codeownersFile).map {
+                    ownersMap[fileType] = it ?: return@map
                 }
             }
         }
         LOGGER.trace("<getFileOwners ${file.name} '${ownersMap.entries.joinToString(",")}'")
-        return expiringStatusCache.set(file, ownersMap)
+        expiringStatusCache[file] = ownersMap
+        return Right(ownersMap)
     }
 
     @Suppress("ReturnCount")
-    private fun getFileOwners(file: VirtualFile, codeownersFile: CodeownersEntryOccurrence): OwnersFileReference? {
-        val codeownersVirtualFile = codeownersFile.file ?: return null
-        var relativePath = getRoot(codeownersVirtualFile)?.let {
-            Utils.getRelativePath(it, file)
-        } ?: return null
+    private fun getFileOwners(file: VirtualFile, codeownersFile: CodeownersEntryOccurrence): Either<GetFileOwnersError, OwnersFileReference?> {
+        val codeownersVirtualFile = codeownersFile.file ?: return Left(GetFileOwnersError.NoVirtualFile)
+        var relativePath = getRelativePathToTheNearestVcsRoot(codeownersVirtualFile) ?: return Right(null)
 
         relativePath =
             StringUtil.trimEnd(StringUtil.trimStart(relativePath, VfsUtilCore.VFS_SEPARATOR), VfsUtilCore.VFS_SEPARATOR)
         if (StringUtil.isEmpty(relativePath)) {
-            return null
+            return Right(null)
         }
         if (file.isDirectory) {
             relativePath += "/"
@@ -219,27 +231,34 @@
 //                return@lastOrNull false
         }?.let {
             LOGGER.trace("<<<getFileOwners pattern ${it.first} matches $relativePath")
-            return@let OwnersFileReference(codeownersVirtualFile.url, it.second)
+            return@let Right(OwnersFileReference(codeownersVirtualFile.url, it.second))
         }
             ?: file.parent.let { directory ->
                 vcsRoots.forEach { vcsRoot ->
                     ProgressManager.checkCanceled()
                     if (directory == vcsRoot.path) {
-                        return@let OwnersFileReference(codeownersVirtualFile.url, OwnersReference())
+                        return@let Right(OwnersFileReference(codeownersVirtualFile.url, OwnersReference()))
                     }
                 }
                 return@let getFileOwners(file.parent, codeownersFile)
             }
     }
 
-    private fun getRoot(codeownersVirtualFile: VirtualFile): VirtualFile? {
-        val vcsRoot = vcsRoots
-            .minByOrNull {
-                VfsUtilCore.getRelativePath(it.path, codeownersVirtualFile)?.run {
-                    split(VfsUtilCore.VFS_SEPARATOR_CHAR).count()
-                } ?: 0
-            } ?: return null
-        return (codeownersVirtualFile.fileType as CodeownersFileType).getRoot(vcsRoot, codeownersVirtualFile)
+    /**
+     * Find root for given codeowners file relatively to the nearest VCS root, if any
+     */
+    private fun getRelativePathToTheNearestVcsRoot(codeownersVirtualFile: VirtualFile): String? {
+        return vcsRoots
+            .asSequence()
+            .mapNotNull {
+                val relativePath = VfsUtilCore.getRelativePath(it.path, codeownersVirtualFile)
+                    ?: return@mapNotNull null
+                val distance = relativePath.split(VfsUtilCore.VFS_SEPARATOR_CHAR).count()
+                Pair(relativePath, distance)
+            }
+            .minByOrNull { it.second }
+            ?.first
+            ?: return null
     }
 
     val isAvailable: Boolean get() = working && codeownersFilesExist() ?: false
@@ -247,13 +266,20 @@
     // TODO think about how to avoid this calculation and use index?
     @Suppress("ReturnCount")
     private fun codeownersFilesExist(): Boolean? {
-        val projectDir = project.guessProjectDir() ?: return null
-        val directory = PsiManager.getInstance(project).findDirectory(projectDir) ?: return null
-
-        val filename = CodeownersFileType.INSTANCE.codeownersLanguage.filename
-        val file = directory.findFile(filename)
-
-        return file?.virtualFile ?: directory.virtualFile.findChild(filename) != null
+        return CodeownersBundle.LANGUAGES
+            .asSequence()
+            .map { it.filename }
+            .distinctBy { it }
+            .any {
+                FilenameIndex.getVirtualFilesByName(it, ProjectScope.getProjectScope(project)).isNotEmpty()
+            }
+//        val projectDir = project.guessProjectDir() ?: return null
+//        val directory = PsiManager.getInstance(project).findDirectory(projectDir) ?: return null
+//
+//        val filename = CodeownersFileType.INSTANCE.codeownersLanguage.filename
+//        val file = directory.findFile(filename)
+//
+//        return file?.virtualFile ?: directory.virtualFile.findChild(filename) != null
     }
 
     /** Enable manager. */
Index: src/main/kotlin/com/github/fantom/codeowners/util/MatcherUtil.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/kotlin/com/github/fantom/codeowners/util/MatcherUtil.kt b/src/main/kotlin/com/github/fantom/codeowners/util/MatcherUtil.kt
--- a/src/main/kotlin/com/github/fantom/codeowners/util/MatcherUtil.kt	
+++ b/src/main/kotlin/com/github/fantom/codeowners/util/MatcherUtil.kt	
@@ -40,7 +40,7 @@
          * @param path  to check
          * @return path contains any of the parts
          */
-        fun matchAnyPart(parts: Array<String>, path: String?) = parts.any { path?.contains(it) ?: false }
+        fun matchAnyPart(parts: Array<String>, path: String) = parts.any { path.contains(it) }
 
         /**
          * Extracts alphanumeric parts from  [Pattern].
Index: src/main/kotlin/com/github/fantom/codeowners/CodeownersBarPanel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/kotlin/com/github/fantom/codeowners/CodeownersBarPanel.kt b/src/main/kotlin/com/github/fantom/codeowners/CodeownersBarPanel.kt
--- a/src/main/kotlin/com/github/fantom/codeowners/CodeownersBarPanel.kt	
+++ b/src/main/kotlin/com/github/fantom/codeowners/CodeownersBarPanel.kt	
@@ -1,6 +1,6 @@
 package com.github.fantom.codeowners
 
-import com.github.fantom.codeowners.file.type.CodeownersFileType
+import arrow.core.Either
 import com.intellij.openapi.actionSystem.DataContext
 import com.intellij.openapi.components.service
 import com.intellij.openapi.diagnostic.Logger
@@ -16,11 +16,19 @@
 import com.intellij.openapi.wm.impl.status.EditorBasedStatusBarPopup
 import com.jetbrains.rd.util.first
 
+inline fun <E, T> Either<E, T>.unwrap(f: (E) -> Nothing): T =
+    when (this) {
+        is Either.Left -> f(this.value)
+        is Either.Right -> this.value
+    }
+
 class CodeownersBarPanel(project: Project) : EditorBasedStatusBarPopup(project, false) {
     companion object {
         private val LOGGER = Logger.getInstance(CodeownersBarPanel::class.java)
     }
 
+    private val manager = project.service<CodeownersManager>()
+
     override fun ID(): String {
         return "CodeownersPanel"
     }
@@ -30,23 +38,33 @@
         return state
     }
 
-    private fun getFileOwners(file: VirtualFile): Map<CodeownersFileType, OwnersFileReference>? {
-        val manager = project.service<CodeownersManager>()
-        return manager.getFileOwners(file)
-    }
-
+//    private fun getFileOwners(file: VirtualFile): Map<CodeownersFileType, OwnersFileReference>? {
+//        return manager.getFileOwners(file)
+//    }
+//
     @Suppress("ReturnCount")
     override fun getWidgetState(file: VirtualFile?): WidgetState {
-        LOGGER.trace("getWidgetState")
+        LOGGER.trace("getWidgetState for file $file")
         if (file == null) {
-            return getWidgetStateWithIcon(WidgetState.HIDDEN)
+//        return getWidgetStateWithIcon(WidgetState.HIDDEN)
+            return getWidgetStateWithIcon(WidgetState.getDumbModeState("Codeowners", "File is null: "))
+        }
+        if (!manager.isAvailable) {
+//        return getWidgetStateWithIcon(WidgetState.HIDDEN)
+            return getWidgetStateWithIcon(WidgetState.getDumbModeState("Codeowners", "Not available: "))
         }
-        val ownersMap = getFileOwners(file)
-            ?: return getWidgetStateWithIcon(WidgetState.getDumbModeState("Codeowners", "Codeowners:"))
+        val ownersMap = manager.getFileOwners(file)
+            .unwrap {
+                return getWidgetStateWithIcon(WidgetState.getDumbModeState("Codeowners", "Codeowners $it:"))
+            }
 
         val (toolTipText, panelText, actionIsAvailable) = when (ownersMap.size) {
-            0 -> Triple("No CODEOWNERS files found", "<No CODEOWNERS>", false)
+            0 -> {
+//                return WidgetState.HIDDEN
+                Triple("No CODEOWNERS files found", "<No CODEOWNERS>", false)
+            }
             1 -> {
+                // TODO handle multiple codeowners files case
                 val owners = ownersMap.first().value.ref.owners
                 when (owners.size) {
                     0 -> Triple("No owners are set for current file", "<No owners>", true)
@@ -74,9 +92,11 @@
 
     @Suppress("ReturnCount")
     override fun createPopup(context: DataContext?): ListPopup? {
-        val owners = getFileOwners(selectedFile ?: return null)
+        val owners = manager
+            .getFileOwners(selectedFile ?: return null)
+            .unwrap { return null }
         when {
-            owners === null || owners.isEmpty() -> return null
+            owners.isEmpty() -> return null
             owners.size == 1 -> {
                 val ref = owners.entries.first().value
                 goToOwner(ref.url ?: return null, ref.ref.offset)
Index: src/main/kotlin/com/github/fantom/codeowners/settings/CodeownersSettings.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/kotlin/com/github/fantom/codeowners/settings/CodeownersSettings.kt b/src/main/kotlin/com/github/fantom/codeowners/settings/CodeownersSettings.kt
--- a/src/main/kotlin/com/github/fantom/codeowners/settings/CodeownersSettings.kt	
+++ b/src/main/kotlin/com/github/fantom/codeowners/settings/CodeownersSettings.kt	
@@ -34,7 +34,7 @@
             field = value
         }
 
-    /** Enable CODEOWNERS file status coloring. */
+    /** Enable CODEOWNERS plugin? IDK if is it useful at all. */
     var codeownersFileStatus = true
         set(value) {
             notifyOnChange(KEY.CODEOWNERS_FILE_STATUS, codeownersFileStatus, value)
