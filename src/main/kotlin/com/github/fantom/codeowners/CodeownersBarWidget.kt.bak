package com.github.fantom.codeowners

import com.github.fantom.codeowners.file.type.CodeownersFileType
import com.intellij.openapi.components.service
import com.intellij.openapi.fileEditor.FileEditorManager
import com.intellij.openapi.fileEditor.FileEditorManagerEvent
import com.intellij.openapi.fileEditor.OpenFileDescriptor
import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.popup.JBPopupFactory
import com.intellij.openapi.ui.popup.ListPopup
import com.intellij.openapi.ui.popup.PopupStep
import com.intellij.openapi.ui.popup.util.BaseListPopupStep
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.openapi.vfs.VirtualFileManager
import com.intellij.openapi.wm.StatusBar
import com.intellij.openapi.wm.StatusBarWidget
import com.intellij.openapi.wm.impl.status.EditorBasedWidget
import com.intellij.refactoring.listeners.RefactoringEventData
import com.intellij.refactoring.listeners.RefactoringEventListener
import com.intellij.util.Consumer
import com.jetbrains.rd.util.first
import java.awt.event.MouseEvent

// class CodeownersBarWidgetFactory : StatusBarWidgetFactory {
//    override fun getId() = CodeownersBarWidget.ID
//
//    override fun getDisplayName() = "Code Owners"
//
//    override fun disposeWidget(widget: StatusBarWidget) = Disposer.dispose(widget)
//
//    override fun isAvailable(project: Project): Boolean {
//        return true
// //        return ModuleManager.getInstance(project).modules.any { module ->
// //            CodeOwners(project).findCodeOwnersFile(module.guessModuleDir()) !== null
// //        }
//    }
//
//    override fun createWidget(project: Project) = CodeownersBarWidget(project)
//
//    override fun canBeEnabledOn(statusBar: StatusBar) = true
// }

@Suppress("TooManyFunctions")
class CodeownersBarWidget(project: Project) :
    EditorBasedWidget(project),
    StatusBarWidget.MultipleTextValuesPresentation,
    RefactoringEventListener {

    private var currentOrSelectedFile: VirtualFile? = null
//    private var currentFilePath: String? = null
//    private var currentFileRule: CodeOwnerRule? = null
//    private val codeOwnersService: CodeOwners = CodeOwners(project)

    override fun install(statusBar: StatusBar) {
        super.install(statusBar)
        myConnection.subscribe(RefactoringEventListener.REFACTORING_EVENT_TOPIC, this)
    }

    override fun ID() = ID

    override fun getTooltipText() = "Click to show in CODEOWNERS file"

    private fun getFileOwners(file: VirtualFile): Map<CodeownersFileType, OwnersFileReference>? {
        val manager = project.service<CodeownersManager>()
        return manager.getFileOwners(file)
    }

    private fun getFileOwners(): Map<CodeownersFileType, OwnersFileReference>? = currentOrSelectedFile?.let(::getFileOwners)

    @Suppress("ReturnCount")
    override fun getSelectedValue(): String {
        if (currentOrSelectedFile === null) return "No file open"
//        val owners = getCurrentCodeOwnerRule()?.owners ?: return "Owner: None"
        val ownersMap = getFileOwners(currentOrSelectedFile!!) ?: return "Dumb mode"
        val (toolTipText, panelText) = when (ownersMap.size) {
            0 -> Pair("No CODEOWNERS files found", "<No CODEOWNERS>")
            1 -> {
                val owners = ownersMap.first().value.ref.owners
                when (owners.size) {
                    0 -> Pair("No owners are set for current file", "<No owners>")
                    1 -> Pair("Owner: ${owners[0]}", owners[0].owner)
                    else -> Pair("""All owners: ${owners.joinToString(", ")}""", "${owners[0].owner}...")
                }
            }
            else -> Pair("""All owners: ${ownersMap.entries.joinToString(", ")}""", ownersMap.first().value.ref.owners[0].owner)
        }
        return panelText
//        val first = owners.first()
//        val numOthers = owners.size - 1
//        return when {
//            (numOthers == 1) -> "Owners: $first & 1 other"
//            (numOthers > 1) -> "Owners: $first & $numOthers others"
//            else -> "Owner: $first"
//        }
    }

    override fun getClickConsumer(): Consumer<MouseEvent>? = null

    override fun getPresentation(): StatusBarWidget.WidgetPresentation = this

    /** Return a popup listing all code owners for a file */
    @Suppress("ReturnCount")
    override fun getPopupStep(): ListPopup? {
//        val owners = getCurrentCodeOwnerRule()
        val owners = getFileOwners()
        when {
            owners === null || owners.isEmpty() -> return null
            owners.size == 1 -> {
                val ref = owners.entries.first().value
                goToOwner(ref.url ?: return null, ref.ref.offset)
                return null
            }
            else -> {
                data class Ref(val url: String, val offset: Int)
                return JBPopupFactory.getInstance().createListPopup(
                    object : BaseListPopupStep<Ref>("All CODEOWNERS Files", owners.values.map { Ref(it.url!!, it.ref.offset) }) {
                        override fun onChosen(selectedValue: Ref?, finalChoice: Boolean): PopupStep<*>? {
                            selectedValue?.also {
                                goToOwner(it.url, it.offset)
                            }
                            return super.onChosen(selectedValue, finalChoice)
                        }
                    }
                )
            }
        }
    }

    /** Open the CODEOWNERS file, and navigate to the offset which defines the owner of the current file */
    private fun goToOwner(codeownersFileUrl: String, offset: Int) {
//        val codeOwnersFile = codeOwnersService.findCodeOwnersFile(currentOrSelectedFile)
        val codeownersFile = VirtualFileManager.getInstance().findFileByUrl(codeownersFileUrl) ?: return
//        val vf = codeOwnersFile?.toPath()?.let { VirtualFileManager.getInstance().findFileByNioPath(it) } ?: return
//        OpenFileDescriptor(project, vf, currentFileRule?.lineNumber ?: 0, 0).navigate(true)
        OpenFileDescriptor(project, codeownersFile, offset).navigate(true)
    }

    /** Get CodeOwner rule for the currently opened file */
//    private fun getCurrentCodeOwnerRule(): CodeOwnerRule? {
//        // Reload CodeOwners if the current file has changed
//        val file = currentOrSelectedFile ?: return null
//        if (file.path != currentFilePath) {
//            currentFilePath = file.path
//            currentFileRule = codeOwnersService.getCodeOwners(file)
//        }
//        return currentFileRule
//    }

    private fun update(file: VirtualFile?) {
        // TODO In theory we should just be able to use this.selectedFile, but for some reason,
        // sometimes the EditorBasedWidget loses its ability to find the currently selected file.
        // Therefore, we allow editor events to pass in the switched-to file, which seems to be
        // more reliable.
        currentOrSelectedFile = file ?: selectedFile ?: currentOrSelectedFile
        myStatusBar.updateWidget(ID())
    }
    // Listen to Editor events and update the status bar when switching or renaming files
    override fun selectionChanged(event: FileEditorManagerEvent) = update(event.newFile)
    override fun undoRefactoring(refactoringId: String) = update(null)
    override fun refactoringDone(refactoringId: String, afterData: RefactoringEventData?) = update(null)
    override fun fileOpened(source: FileEditorManager, file: VirtualFile) { /* ignored */ }
    override fun refactoringStarted(refactoringId: String, beforeData: RefactoringEventData?) { /* ignored */ }
    override fun conflictsDetected(refactoringId: String, conflictsData: RefactoringEventData) { /* ignored */ }

    companion object {
        internal const val ID = "org.brex.plugins.codeowners.CodeOwnersWidget"
    }
}
